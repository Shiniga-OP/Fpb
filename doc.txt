documentação da FPB (Fácil Programação Baixo nível).

## BÁSICO ##

para começar, um código padrão de "Olá mundo":

[código]
#incluir "biblis/impressao.asm";
#global inicio();

vazio inicio() {
    escrever("Olá mundo\n");
}
[código]

e compile com "fpb ola.fpb" ou "fpb ola.fpb -s ola" caso queira definir o nome final.
digite "fpb -ajuda" para visualizar todos os comandos.

agora a explicação de cada parte:

"#incluir" é da categoria de diretivas (#), ela serve para colar códigos Assembly no seu código intermediário. Assim você poderá utilizar funções definidas no Assembly.

"#global" é da categoria "#", e serve para expôr uma função para outros códigos que desejem chamar funções do seu código externamente. Utilizamos essa função para que o sistema operacional possa executar nosso código começando por "inicio()".

"vazio" é da categoria de retornos, significa que o valor que sua função retorna é nulo, ou seja, nada. Ele não é um tipo de variável, então não é possível atribuir um valor nulo diretamente a um variável que não seja por retorno.

"inicio()" é o nome da função, que serve para identificar, diferenciar, e chamá-la no código em si.

"escrever();" é da categoria de funções nativas do compilador, ela é uma abstração padrão que divide o trabalho em outras funções do sistema. Quando você faz:

## FUNÇÕES NATIVAS DO COMPILADOR ##

[código]
escrever("texto", 15, 15.0f);
[código]

na verdade isso vira: "_escrever_tex();", "_escrever_int();", e "_escrever_flu();" em sequência.

também existe o _asm_(...); que é o assembly manual, onde você pode utilizar assim por exemplo:

[código]
#global inicio();

vazio inicio() {
    car* p = "texto";
    _asm_(
        "   mov x0, ", 1, '\n',
        "   ldr x1, ", p, '\n',
        "   mov x2, ", 5, '\n',
        "   mov x8, ", 64, '\n',
        "   svc ", 0
    );
}
[código]

no assembly manual, ponteiros e variaveis sempre dão seus endereços, mesmo sem o operador "@", a unica excessão são números literais.

toda e qualquer operação externa que interaja com o assembly manual precisa ser via ponteiro, variavel global, macro, ou literal, nunca variaveis locais mesmo que sejam finais.

"biblis/impressao.asm" é a biblioteca de impressão que contém as funções de impressão padrão, como as anteriores e "_escrever_car();", "_escrever_longo();", a mais.

## TIPAGEM ##

FPB é uma linguagem fortemente tipada, isso significa que você precisa definir os tipos das variáveis antes de declarar elas, e não pode passar valores.

[código]
car caractere = 'A';
int inteiro = 1;
flu flutuante = 1.0f;
bool booleano = falso;
longo numeroLongo = 999999999L;
byte hexadecimal = 0x000000;
[código]

para valores byte acima de 1 byte, é melhor usar o tipo int, de 4 bytes, ou o tipo longo, de 8 bytes.

e ponteiros:

[código]
car* texto = "ponteiro de texto";
int* inteiro = 15;
flu* flutuante = 1.5f;
bool* booleano = verdade;
longo* numeroLongo = 999999999999L;
byte* hexadecimal = 0x000000;
[código]

arrays:

[código]
car[] texto = "array de texto";
int[] inteiros = { 1, 1, 1 };
flu[] flutuantes = { 1f, 1f, 1f };
bool[] booleanos = { verdade, verdade, verdade };
longo[] longos = { 1L, 1L, 1L };
byte[] bytes = { 0xFF, 0xFF, 0xFF };
[código]

ao imprimir hexadecimal, ele aparecerá em decimal comum.

você também pode tornar uma variavel imútavel com "final".

[código]
final int x = 0;
[código]

agora ela nunca poderá ser reatribuida no código FPB.

## CONDICIONAIS ##

condicionais são abrangentes, você pode fazer:

[código]
se(!booleano) escrever("resultado");
[código]

caso o booleano seja falso, irá executar a chamada.

ou

[código]
se(booleano) escrever("resultado");
[código]

caso seja verdade, vai executar a chamada.

você também pode usar condições aninhadas:

[código]
se(booleano && !booleano2 && booleano3) escrever("resultado");
[código]

só vai executar se todas as condições forem atendidas.

[código]
se(booleano || !booleano2 || booleano3) escrever("resultado");
[código]

vai executar se qualquer condição for atendida.

e também:

se(condicao) escrever("foi de primeira");
senao se(outra_condicao) escrever("foi de segunda");
senao escrever("não foi");

ah é, você pode usar com chaves também:

se(condicao) {
    escrever("foi");
} senao {
    escrever("não foi");
}

## ARRAYS ##

você pode utilizar arrays de várias maneiras, e uma peculiaridade especial da FPB são seus arrays de texto mutáveis, diferente de outras linguagens onde um array de caracteres é um ponteiro imutável, na FPB os arrays de caracteres são totalmente temporários:

[código]
car[30] array = "array de caracteres temporário"; // mutável
array[0] = 'A'; // funciona
car* ponteiro = "ponteiro de texto permanente"; // texto imutável
ponteiro[0] = 'A'; // erro
[código]

arrays não podem ser reatribuidos diretamente nem serem retornados de funções. Por isso, funções utilizam arrays como ponteiros, e toda alteração feita neles de qualquer parte do código onde são passados como referência.

[código]
#incluir "biblis/impressao.asm";
#global inicio();

vazio modificar(int[] arr) {
    arr[0] = 1;
}

vazio inicio() {
    int[] arr = { 5 };
    modificar(arr);
    escrever(arr[0]); // vai imprimir 1
}
[código]

## PONTEIROS ##

os ponteiros da FPB tem dereferência automática. Isso significa que você não precisa adicionar uma expressão explícita para manipular seu valor.

comparação:

em C:

[código]
int x = 10;
int* p = &x;
*p = *p + 1;
[código]

em FPB:

[código]
int x = 10;
int* p = @x;
p = p + 1;
[código]

o operador "@" serve para acessar diretamente o endereço de uma variável ou ponteiro, isso significa que ao usar "@variavel", você estará acessando o endereço da memória ou pilha, não o valor da variável.

ponteiros também podem ter seus endereços mudados manualmente, mesmo que em suas declarações, você possa passar o endereço sem "@", caso você queira alterar o endereço de um ponteiro já declarado, poderá usar o operador "@" também para isto:

[código]
int x = 10;
int* p;
@p = @x;

// ou:

@p = 0x000000;
[código]

assim você estará alterando manualmente o endereço do ponteiro declarado.

o operador "*" pode somente ser usado para multiplicações e para declaração de ponteiros. Nunca em uma expressão complexa.

## LOOPS ##

você pode criar loops de 3 formas:

1. A mais fácil é simplesmente chamar a função de forma recursiva.

[código]
vazio loop() {
    loop();
}
[código]

2. loop enq, é um loop condicional que executa até a condição ser atendida.

[código]
int x = 0;
enq(x > 10) {
    escrever(x, "\n");
    x++;
}
[código]

3. loop por, é um loop condicional incremental, o que significa que ele pode declarar uma variável temporária e executar até a condição seja atendida enquanto faz alguma alteração na variável temporária.

[código]
por(int i = 0; i < 10; i++) {
    escrever(i, "\n");
}
[código]

você também tem acesso a instruções em loops, como o "pare", que termina o loop instantaneamente:

[código]
por(int i = 0; i < 10; i++) {
    escrever("i = ", i, "\n");
    se(i == 5) {
        pare;
    }
}
[código]

isso vai terminar o loop quando imprimir "i = 5" no terminal.

## GLOBAIS ##

funções globais são definidas sem retorno:

[código]
#global funcao();
[código]

variaveis globais são definidas normalmente com o tipo e valor:

[código]
#global int var = 0;
[código]

## CONVERSORES ##

para converter código, você pode utilizar "(tipo)" antes da atribuição ou passagem.

exemplo:

[código]
escrever((car)45);
[código]

será imprimido um caractere convertido para hexadecimal.

ponteiros não são tipos de conversão.

## RETORNOS ##

você pode usar:

[código]
retorne
[código]

## OPERADORES ##

os matematicos são:

"+" soma.
"-" subtrai.
"*" multiplica.
"/" divide.
"%" captura o resto da porcentagem.
"<<" multiplica pela potência de 2.
">>" divide pela potência de 2.
"&" captura o resto da porcentagem pela potência de 2
"|" se qualquer um dos dois bits for 1, adiciona o bit 1 ao resultado final.
"()" altera a ordem de precêdencia.
"+=, -=, *=, /=, %=" são operadores compostos.

os condicionais são:

"==" se for igual.
"!=" se for diferente.
">=" se for maior ou igual.
"<=" se for menor ou igual.
">" se for somente maior.
"<" se for somente menor.
"&&" somente se for também verdadeiro.
"||" se algum dos dois for verdadeiro.
"condição ? seForVerdade : seForFalso;" condição mais simples.

os de memória são:

"@" aponta o endereço na memória (não funciona com valores não armazenados).

## MACROS ##

você pode usar #def para definir macros númericos de inteiro ou longo.

[código]
#def INTEIRO 172834;
[código]

## BIBLIOTECAS ##

importe bibliotecas padrão da FPB com: "#include caminho;".

você pode importar bibliotecas FPB também, e usar seus códigos.

que não dependem de chamadas do sistema:

"biblis/texs.fpb": contém:

// retorna 1 se os textos forem verdadeiros e 0 senão.
int texcmp(car* p1, car* p2);

// substitui um caractere de um array por outro
vazio subscar(car[] arr, car cAlvo, car novoC);

// retorna o tamanho em bytes de um texto
int textam(car* p);

// retorna 1 se o texto tem o caractere e 0 senão
int texcar(car* p, car c);

"biblis/cvts.fpb": contém:

// converte o texto em número inteiro e retorna o valor
int cvtint(car[] v, int tam);

// converte o texto em número flutuante e retorna o valor
flu cvtflu(car[] v, int tam);

que dependem de chamadas do sistema:

"biblis/impressao.asm": contém:

todas as funções de impressão padrão para "escrever(...);" funcionar.

porém pode ser facilmente substituida por outra biblioteca que tenha os mesmos nomes e parâmetros, ou linkada a uma que tenha, assim não precisando importar.

"biblis/sistema.asm": contém:

// retorna o tempo em milissegundos
longo obter_tempo_milis();

"biblis/mem.fpb": contém:

// copia os bytes do ponteiro para o array
vazio memcp(car[] arr, car* p, int tam);

// retorna memória RAM do heap nativo
int* memalocar(int bytes);

// libera memória RAM do heap nativo
vazio memliberar(int* p, int bytes);

"biblis/mat.fpb": contém:

// retorna a formúla de tanh em flutuante
flu ftanh(flu x);
// retorna a formúla de exp em flutuante
flu fexp(flu x);
// retorna a raiz quadrada em flutuante
flu fraiz(flu x);

// variaveis:
PI = 3.14159265f;
flu E = 2.71828182f;
RAIZ2 = 1.41421356f;
LOG2E = 1.44269504f;
LOGE10 = 2.30258509f;

## ESPAÇOS ##

espaços são estruturas de dados leves, com a diretiva #espaco, você pode definir um espaço para guardar variaveis e organizá-las por categorias.

[código]
#espaco Pessoa {
    car nome;
    int idade;
    byte endereco;
}
[código]

para acessar ou configurar um novo espaço apartir do padrão, você pode fazer:

[código]
Pessoa p1;
p1.nome = 'A';
p1.idade = 32;
p1.endereco = 0x000000;

Pessoa p2;
p2.nome = 'B';
p2.idade = 34;
p2.endereco = 0x000100; 
[código]

espaços não podem ser passados como parâmetros ainda.

## ALINHAMENTO & MEMÓRIA ##

O #alinhar numero; é o equivalente a alinhar qualquer coisa em assembly.

Usando bytes(alguma_variavel_ou_ponteiro), você pode receber os bytes daquilo.

Isso também serve com textam(var), da biblioteca "texs.fpb", mas caso não tenha acesso a ela ou você so seja fresco mesmo, pode usar a de nome bonito e nativa do compilador.

Essa função so retorna o tamanho em bytes de variaveis/ponteiros, NÃO de TIPOS, como IDs de estruturas ou tipos primitivos de variaveis.

Exemplo:

ERRADO:

[código]
Pessoa* p = memalocar(bytes(Pessoa));
memliberar(p, bytes(Pessoa));
[código]

CERTO:

[código]
Pessoa* p = memalocar(bytes(p));
memliberar(p, bytes(p));
[código]